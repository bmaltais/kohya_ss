from http.client import HTTPException
import os
import asyncio
from typing import Callable
from cuid2 import cuid_wrapper
from fastapi import Depends, FastAPI, BackgroundTasks
from sqlalchemy.orm import Session
import boto3
from botocore.config import Config
from dotenv import load_dotenv

from . import models, schemas
from .database import SessionLocal, engine
from .tasks import train_lora_model

models.Base.metadata.create_all(bind=engine)

load_dotenv()

app = FastAPI()

AWS_ACCESS_KEY_ID = os.environ.get("AWS_ACCESS_KEY_ID")
AWS_SECRET_ACCESS_KEY = os.environ.get("AWS_SECRET_ACCESS_KEY")
BUCKET_NAME = "gazai"
s3_config = Config(
    retries={"max_attempts": 10, "mode": "adaptive"},
    connect_timeout=120,
    read_timeout=300,
)
s3 = boto3.client(
    "s3",
    aws_access_key_id=AWS_ACCESS_KEY_ID,
    aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
    region_name="ap-northeast-1",
    config=s3_config,
)


# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


cuid_generator: Callable[[], str] = cuid_wrapper()


@app.post("/model/train")
def create_and_train_model(
    lora_model_data: schemas.LoraModelCreate, db: Session = Depends(get_db)
):
    # Save the model data to your database first
    db_model = models.LoraModel(
        id=cuid_generator(), **lora_model_data.model_dump(exclude={"trainingImageIds"})
    )
    db.add(db_model)
    for image_id in lora_model_data.trainingImageIds:
        # Retrieve or create TrainingImage instances
        training_image = db.query(models.Image).filter_by(id=image_id).first()
        if not training_image:
            training_image = models.Image(id=image_id)  # Add necessary fields
            db.add(training_image)
        db_model.trainingImages.append(training_image)
    db.commit()
    db.refresh(db_model)  # Get the id generated by the database

    # Now, start the training task
    task = train_lora_model.delay(db_model.to_dict())

    return db_model

@app.post("/model/train/{model_id}")
def train_model(
    model_id: str, background_tasks: BackgroundTasks, db: Session = Depends(get_db)
):
    lora_model = db.query(models.LoraModel).filter_by(id=model_id).first()
    if not lora_model:
        raise HTTPException(status_code=404, detail="Model not found")
    lora_model.status = models.LoraModelStatus.PENDING
    db.commit()
    db.refresh(lora_model)

    task = train_lora_model.delay(lora_model.to_dict())
    return {"message": f"Training for model {model_id} started in the background"}


@app.post("/model/{model_id}/download")
def upload_model(
    model_id: str, background_tasks: BackgroundTasks, db: Session = Depends(get_db)
):
    lora_model = db.query(models.LoraModel).filter_by(id=model_id).first()
    object_key = lora_model.objectKey

    # Define the background task
    async def download_file_task():
        try:
            await asyncio.to_thread(
                s3.download_file,
                BUCKET_NAME,
                object_key,
                f"/workspace/stable-diffusion-webui/models/Lora/{object_key.split('/')[-1]}",
            )
            print(f"File download completed for model {model_id}")
        except Exception as e:
            print(f"Error downloading file for model {model_id}: {str(e)}")

    # Add the task to background tasks
    background_tasks.add_task(download_file_task)

    return {"message": f"Download for model {model_id} started in the background"}
